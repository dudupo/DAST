
\input{../texlib/head}
\begin{document}
\setcounter{chapter}{4}
\chapter{Reserves Recitation.} 



\section{}
Another sorting algorithms, that it's correctness isn't so obivoius.  


\begin{algorithm}
\SetAlgoLined
\KwResult{returns the multiplication \(x\cdot y\) where \(x,y \in \mathbb{F}^{n}_{2}\) }
\For{ $ i \in [n]$} {
  \For{ $ j \in [n]$} {
    \If { $A_{j} < A_{i} $} {
      swap $A_{i} \leftrightarrow A_{j}$
    }
  }
}


\end{algorithm}

\begin{claim}
  After the $i$th iteration, $A_{1} \le A_{2} \le A_{3} .. \le A_{i}$ and $A_{i}$ is the maximum of the whole array. 
\end{claim}
\begin{proof}
  By induction on the iteration number $i$. 
  \begin{enumerate}
    \item Base. For $i=1$, it is clear that when $j$ reaches the position of the maximal element, an exchange will occur and $A_{1}$ will be set to be the maximal element. Thus, the condition on line (3) will not be satisfied until the end of the inner loop and indeed, we have that $A_{1}$ at the end of the first iteration is the maximum.
    \item Assumption. Assume the correctness of the claim for any $i^{\prime} < i$. 
    \item Step. Consider the $i$th iteration. And observes that if $A_{i} = A_{i-1}$ then $A_{i}$ is also the maximal elememnt in $A$, namely no exchange will be made in $i$th iteration, yet $A_{1} \le A_{2} \le .. \le A_{i-1}$ by the induction assumption, thus  $A_{1} \le A_{2} \le .. \le A_{i-1} \le A_{i}$ and $A_{i}$ is the maximal element, so the claim holds in the end of the iteration. 
      If $A_{i} < A_{i-1}$ then there exists $k \in [1,i-1]$ such $A_{k} > A_{i}$. Set $k$ to be the minimal position for which the inequlity holds. For Convinet denote by $A^{(j)}$ the array in the begging of the $j$th iteration of the inner loop. And let's split to cases according to $j$ value. 
      \begin{enumerate}
        \item $j < k$
        \item $j \ge k$
        \item $j > i-1$
      \end{enumerate}<++>
  \end{enumerate}
\end{proof}


%\author{Master theorem and recursive trees.}
% 
%\begin{abstract}
%    One of the standard methods to analyze the running time of algorithms is to express recursively the number of operations that are made. In the following recitation, we will review the techniques to handle such formulation (solve or bound).  
%\end{abstract}
%
\begin{algorithm}
\SetAlgoLined
\KwResult{returns the multiplication \(x\cdot y\) where \(x,y \in \mathbb{F}^{n}_{2}\) }
 \ \\ 
 \If{ \(x,y \in \mathbb{F}_{2}\) }
    { return \(x \cdot y\) } 
 \ \\ 
 
 \Else {
 define \(x_{l} , x_{r} \leftarrow x \) and \(y_{l} , y_{r} \leftarrow x \) \ \ \ \ \ // \( O \left(n\right) \). \\ 
 \ \\ 
 calculate \(z_0 \leftarrow \text{Karatsuba}\left(x_{l},y_{l}\right)\) \\
 \ \ \ \ \ \ \ \ \ \ \ \ \(z_2 \leftarrow \text{Karatsuba}\left(x_{r},y_{r}\right)\) \\ 
 \ \ \ \ \ \ \ \ \ \ \ \ \(z_1 \leftarrow \text{Karatsuba}\left(x_{r} + x_{l} ,y_{l} + y_{r} \right) - z_0 - z_2 \) \\ 
 \ \\
 return \(z_0 + 2^{\frac{n}{2}}z_1 + 2^{n}z_2\) \ \ \ \ \  // \( O \left(n\right) \). 
 }
\end{algorithm}
\input{../texlib/tail}


