\title{Union Find - Recitation 11} 
\input{../texlib/head}
\usetikzlibrary{positioning, arrows}
\tikzset{main node/.style={circle,draw,minimum size=0.8cm,inner sep=0pt},}
\tikzset{edge/.style = {->,> = latex'}}

\iffalse
  \newtheorem{prop}{Proposition}
  \newtheorem{ex}{Exercise}
  \newtheorem{sol}{Solution}
  \newtheorem{theorem}{Theorem} \newtheorem{thm}{Theorem}[section]
  \newtheorem{conj}[thm]{Conjecture} \newtheorem{lemma}[thm]{Lemma}
  \newtheorem{corollary}[thm]{Corollary} \newtheorem{claim}[thm]{Claim}
  \newtheorem{proposition}[thm]{Proposition}
  \newtheorem{definition}{Definition} \newtheorem{remark}{Remark}

  \pagestyle{empty}

  \setlength{\textwidth}{6.5in}
  \setlength{\evensidemargin}{0.0in}
  \setlength{\oddsidemargin}{0.0in}
  \setlength{\topmargin}{-0.25in}
  \setlength{\textheight}{9.0in}
  \setlength{\baselineskip}{1.3\baselineskip}
  \setlength{\parindent}{.0in}
\fi
\tikzset{
  node of list/.style = { 
    draw, 
    fill=orange!20, 
    minimum height=6mm, 
    minimum width=6mm,
    node distance=6mm
  },
  link/.style = {
    -stealth,
    shorten >=1pt
  },
  array element/.style = {
    draw, fill=white,
    minimum width = 6mm,
    minimum height = 10mm
  }
}

\def\LinkedList#1{%
  \foreach \element in \list {
    \node[node of list, right = of aux, name=ele] {\element};
    \draw[link] (aux) -- (ele);
    \coordinate (aux) at (ele.east);
  } 
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\vspace{0.2in}

\section{Union Find.} 

We have mentioned that for finding efficently the minimal spanning tree using kruskal, one has to answer quickly about wheter a pair of vertices $v,u$ share the same connactivity commponent. In this recitation we will presnt a datastructure that will allow us both quering the belonging of given item and mergging groups at efficent time cost. 

The problem define as follow. Given $n$ items $x_1 ... x_{n}$ we would like to maintain the parttion of them into disjointss sets by supporting the following operations:  
\begin{enumerate}
  \item Make-Set$(x)$ create an empty set whose only member is $x$. We could assume that this operation can be called over $x$ only once. 
  \item Union$(x,y)$ merge the set which contains $x$ with the one which contains $y$. 
  \item Find-Set$(x)$ returns a pointer to the set holding $x$. 
\end{enumerate}

Notice that the navie immpleamntion using pointres array, $A$, defined to store at place $i$ a pointer to the set containing $x$ can perform the Find-Set operation at $O\left( 1 \right)$. The bottle neck of that immplemntion is that the mergging will require from us to run over the whole itmes and changes their corresponding  pointer at $A$ one by one. Namly, a running time cost of $\Theta\left( n \right)$ time. Let's review a diffrent approch:

\paragraph{Linked Lists Immplemntation.}
One way to have a non-trival improvmeant is to associate for each set a linked list storing all the elemnents belonging to the set. Each node of those linked lists contains, additilly to it's value and it's sibling pointer, also a pointer for the list itself (the set). Consider again the mergging operation. it's clear that having those lists allow us to uinfind sets by iterating and updating only the elememnts belong to them. Still one more trick is needed for achiving a good running cost. 


\begin{algbox}{Uinon$(x,y)$}
  \begin{algorithm}[H]
    \If{size $A[x] \ge $  size$A[y]$  }{
      size $A[x] \leftarrow $   size $A[x]$ +  size $A[y]$ \\
      \For{  $z \in A[y]$ }{
	$A[z] \leftarrow A[x]$ \\ 
      }
      $A[x] \leftarrow A[x] \cup A[y]$ // $O\left( 1 \right)$ concatenation of linked lists.  
    }\Else{
      Union $\left( y,x \right)$ 
    }
  \end{algorithm}
\end{algbox}

Clearly, executing the above over sets at linear size require at least linear time. Let's anlayze what happens when  mergging $n$ times. As we have allredy seen at graphs, runtime can be measured by counting the total number of operations that each item/vertex do along the whole running. So we can ask our selfes how many times does an item change his location and his set pointer. Assume that at the time when $x$ were changed $A[x]$ containd (before the mergging) $t$ elemenets then immdetly after that $A[x]$ will store at least $2t$ elements: 
\begin{equation*}
  \begin{split}
    \text{size } A^{(t+1)}[x] \leftarrow  \text{size } A^{(t)}[x] +  \text{size } A^{(t)}[y] \ge 2A^{(t)}[x]  
  \end{split}
\end{equation*}
Hence, if we will list down the sizes of the $x$'s set at the momments mergging had occured we could write only $\log n$ nmbers before the excciding the maximal size ($n$). That proves that the number of times vertex changed his pointer is bounded by $\log n$, and the total number of actions costs at most $\Theta\left( n\log n \right)$. 

Noitce that that in the case in which $m = O\left( 1 \right)$ we will still pay much more than nedded. Any how, the next implemmntion is going to give us (enventuly) much faster algorithm.

\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.25\textwidth}
    \begin{tikzpicture}
      \node[main node](1){$1$};
      \node[main node](2)[below = 1cm of 1]{$2$};
      \node[main node](3)[right = 1cm of 1]{$3$};
      \node[main node](4)[below = 1cm of 3]{$4$};

      \draw[edge] (1) to (2);
      \draw[edge] (1) to (4);
      \draw[edge] (4) to (1);
      \draw[edge] (4) to (3);
      \draw[edge] (1) to (3);
      \draw[edge] (3) to (1);
    \end{tikzpicture}  
    \\ \\  
  \end{subfigure} 
  \begin{subfigure}[b]{0.49\textwidth}
    \begin{tikzpicture}
      \foreach \index/\list in {1/{2,3,4,null}, 2/{null}, 3/{1, null}, 4/{1, 3, null}} {
	\node[array element] (aux) at (0,-\index) {\index};
	\LinkedList{\list}
      }
    \end{tikzpicture}  
  \end{subfigure}
  \caption{ Persenting $G$ by array of adjacency lists.  }
\end{figure}


\paragraph{Forest Immplemntation.} Insted of associating each set with a linked list, one might attach a forst. The vertices holds the values of the items, and we could think about the root of each tree as the represtive of the tree. If two vertices $x,y$ share the same root than it's clear than they are belong to the same set. At the initialliztion stage Make-Set defines the vertices as roots of trival trees (single root without any descendants), Then the find method is: 
\begin{algbox}{Find$(x)$}
  \begin{algorithm}[H]
    \While{ $ \pi(x) \neq  $ None } { 
      $ x \leftarrow \pi\left( x \right)$
    }
    Return $x$ 
  \end{algorithm}    
\end{algbox}

We will see that for having the last improvment one slightly change should be setted. But before that lets try to mimic the decsion rule above. Even those we could define a size field for each root and get the same algortihm as above, Insted we will define another field which from first sight looks indentical. Let the rank$\left( v \right)$ of the node $v$ be hight of the $v$. Recall that tree's height define to be the logest path from the root to one of the vertices. 

\paragraph{Union By Rank Huristic\protect\footnote{Corman calls that rule an hursitic, but please noitce that huristics are usually refers to methods that seemes to be efficent ampiricly, yet it doesn't clear how to prove their advantage mathmatclly. Still, in that course we stick to Corman triminalogy.}}. So as we said, first we are going to ensure how to mimic the $\log n$ complexitiy proof under the forst immplemntion. 

\begin{algbox}{Uinon$(x,y)$}
  \begin{algorithm}[H]
    $x\leftarrow $ Find$\left( x \right)$ \\
    $y\leftarrow $ Find$\left( y \right)$ \\
    \If{ $ x \neq y $ }{
      \uIf{ rank$\left( y \right) < $  rank$\left( x \right)$ }{
	$\pi\left( y \right) \leftarrow x$ \\
      }\uElseIf {   rank$\left( y \right) = $  rank$\left( x \right)$ } { 
	$\pi\left( y \right) \leftarrow x$ \\
	rank$\left( x \right) \leftarrow $  rank$\left( x \right) + 1 $ \\  
      } \Else { 
	$\pi\left( x \right) \leftarrow y$ \\
      }
    }
  \end{algorithm}
\end{algbox}
The decison rule at line (4-8) preserves the correcntess of the fowlling claim:
Claim, let $S(r)$ a lower bound over the the size of tree at rank $r$. Then $M\left( r+1 \right) \ge 2M\left( r \right)$. The proof left as excrsice. Assuming the correctness of the claim it holds that $M\left( \log n \right) \ge n $. So it immidetly followes that the running time take at most $n\log n$. Actully we could get even a tighter bound by noitce that a single query is bounded by the rank. and therefore, the total cost is at most $m \cdot \log n$. 

\paragraph{Path Compression Huristic.} The final trick to yield a sub-logaritmic time algorithm is to compress the bruch on which we have allready passed and by that reduce the number of duplicated transitions.     
\begin{algbox}{Find$(x)$}
  \begin{algorithm}[H]
    \If{ $ \pi\left( x \right) \neq $ None}{
      $\pi\left( x \right) \leftarrow $Find$\left( \pi\left( x \right) \right)$
    } 
    Return $\pi\left(x\right)$ 
  \end{algorithm}    
\end{algbox}
Let's analyses the queris cost by counting the edges on which the algorithm went over. Denote by find($v^{(t)}$) the query which was requested at time $t$ and let $P^{(t)}=v,v_{2} .. v_{k}$ be the vertices path on which the algorithm climbe from $v$ up to his root. Now, observes that by comperssing the path the ranks of the verticis in $P$ must be distincit. Now consdier any parttion of the line into set of buckets (segements) $\mathcal{B}= \left\{ B_{i} | B_{i} = [b_{i} ,b_{i+1}] \right\}$. 


\begin{equation*}
  \begin{split}
    T\left( n, m  \right) &= \text{ direact parent move } + \text{ climbing moves  } =    \\
    &=  \text{ direact parent move } + \text{ stage exchange } +  \text{ inner stage } = \\ 
    & \le m + m \cdot | \mathcal{B} | + \sum_{ B \in \mathcal{B} }{ \text{ steps inside B  }   }\\
    & \le m + m \cdot | \mathcal{B} | + \sum_{ B \in \mathcal{B} }{ \sum_{ rank(u) \in B} { \text{ steps inside B started at }u }  }\\
    & \le m + m \cdot | \mathcal{B} | + \sum_{ B \in \mathcal{B} }{ \sum_{ rank(u) \in B}{ |B| }  } %i\\ 
    %& \le m + m \cdot | \mathcal{B} | + \sum_{ B \in \mathcal{B} }{ \frac{n}{\min{B} } |B| }
  \end{split}
\end{equation*}

For example conisder our last calculation, In which we divided the ranges of ranks into $\log n$ buckets at length $1$, $B_{r} = \{r\}$, then as the size of the subtrees at rank $r$ is at least $2^{r}$ we have that the size of $|B_{r}|$ is at most $\frac{n}{2^{r}}$ and that's why:   
\begin{equation*}
  \begin{split}
    \sum_{ b \in \mathcal{B} }{ \sum_{ rank(u) \in B}{ |B| } } &\le \sum_{ b \in \{ [i] | i \in [ \log n ]  \}  }{ \frac{n}{2^{r}} \cdot 1    } \le  2\cdot n
  \end{split}
\end{equation*}

So the total time is at most $m + m \log n + 2n = \Theta\left( n \right)$. And if we would take the $ \log \log n $ buckets such that $B_{i}$ store the  $i$th $ n /  \log \log n $ numbers. Then the sum above will become:   

\begin{equation*}
  \begin{split}
    & \sum_{ b \in \mathcal{B} }{ \sum_{ rank(u) \in B}{ |B| } }  \le \sum_{ b \in \{ B \in \mathcal{B}  \}  }{ \frac{n}{2^{ \frac{  i \log n} { \log \log n  }  }} \cdot \log \log n }    \le  2\cdot n \\ 
    & \le n  \sum_{ b \in \{ B \in \mathcal{B}  \}  }{ 1 \cdot  \cdot \log \log n }    \le  n \left( \log \log n  \right)^{2}   \\
    & \Rightarrow m + m \cdot \log \log n + n \left( \log \log n  \right)^{2}  
  \end{split}
\end{equation*}

Could we done even better? Yes, Consider a nonunifom parttion $ B_{r} = \{ r,  r+ 1 ... 2^{r} \} $. So first qustion one should ask what is $ |\mathcal{B}|$? ( $ \log^{*}\left( n \right) $ ). On the otherhand the number of vertices in which their rank belongs to the $i$th bucket is at most:    
\begin{equation*}
  \begin{split}
    & \text{ maximal number of nodes at rank } r + \text{ maximal number of nodes at rank } (r+1) + \\ 
    & \text{ maximal number of nodes at rank } (r+2) + ... +  \text{ maximal number of nodes at rank } 2^{r} \\  
    & \frac{n}{2^{r}} + \frac{n}{2^{r+1}} + \frac{n}{2^{r+2}} + ... + \frac{n}{2^{2^{r}}} \Rightarrow | \right\{ v \in B_{r} \left\} | \le 2 \cdot \frac{n}{2^{r}} 
  \end{split}
\end{equation*}

\begin{equation*}
  \begin{split}
    \sum_{ b \in \mathcal{B} }{ \sum_{ rank(u) \in B}{ |B| } }  \le 
  \end{split}
\end{equation*}



\input{../texlib/tail}

